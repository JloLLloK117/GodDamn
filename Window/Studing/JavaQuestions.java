package Window.Studing;

import java.util.*;

public enum JavaQuestions {
    EX1_Q1("За что отвечает JVM?", List.of("Компиляция в .exe", "Создание GUI", "Исполнение байткода", "Управление сетью"), 2),
    EX1_Q2("Команда для компиляции программы:", List.of("java", "run", "compile", "javac"), 3),
    EX1_Q3("Главный файл программы должен содержать:", List.of("init()", "main()", "entry()", "start()"), 1),
    EX2_Q1("Файл после компиляции имеет формат:", List.of(".exe", ".byte", ".class", ".obj"), 2),
    EX2_Q2("JDK включает:", List.of("Компилятор + библиотеки", "Только JVM", "Только jar-архиватор", "Только Swing"), 0),
    EX2_Q3("Java — язык:", List.of("нативный машинный код", "низкоуровневый ассемблер", "зависим от ОС", "байткод → JVM"), 3),
    EX3_Q1("Оператор вывода текста:", List.of("console.write()", "Print.text()", "System.out.println(...)", "printf.out()"), 2),
    EX3_Q2("Как объявить переменную?", List.of("var x:", "int x = 10;", "num = 5;", "declare x"), 1),
    EX3_Q3("Тип String является:", List.of("Физическим", "Машинным", "Примитивным", "Ссылочным"), 3),
    EX4_Q1("Какой тип дробный?", List.of("int", "byte", "char", "double"), 3),
    EX4_Q2("Какой тип логический?", List.of("condition", "flag", "logic", "boolean"), 3),
    EX4_Q3("char хранит:", List.of("1 символ", "число double", "строку", "массив"), 0),
    EX5_Q1("new создает:", List.of("метод", "класс", "объект", "переменную"), 2),
    EX5_Q2("Класс — это:", List.of("метод", "пакет", "исключение", "шаблон объекта"), 3),
    EX5_Q3("Объект — это:", List.of("экземпляр класса", "наследник JVM", "бинарный файл", ".exe приложение"), 0),
    EX6_Q1("Как вызвать метод объекта?", List.of("obj.method()", "run method", "method->obj()", "call obj"), 0),
    EX6_Q2("Сколько конструкторов может иметь класс?", List.of("один", "только два", "много", "ни одного"), 2),
    EX6_Q3("Перегрузка методов — это:", List.of("разные return type — запрещено", "замена JVM", "одинаковое имя — разные параметры", "разный класс — один метод"), 2),
    EX7_Q1("this используется для:", List.of("удаления объекта", "обращения к полям объекта", "создания наследника", "сброса JVM"), 1),
    EX7_Q2("Метод без return:", List.of("empty", "void", "none", "blank"), 1),
    EX7_Q3("Конструктор вызывается:", List.of("при компиляции", "при загрузке JVM", "при создании объекта", "после main()"), 2),
    EX8_Q1("Инкапсуляция — это:", List.of("удаление методов", "загрузка ресурсов", "скрытие реализации", "создание потоков"), 2),
    EX8_Q2("private значит:", List.of("везде", "внутри пакета", "доступ только внутри класса", "только наследникам"), 2),
    EX8_Q3("public доступен:", List.of("только в модуле", "всем", "только финальным классам", "внутри JVM"), 1),
    EX9_Q1("extends используется для:", List.of("инкапсуляции", "потоков", "наследования", "полиморфизма"), 2),
    EX9_Q2("super позволяет:", List.of("обращаться к родителю класса", "перезагрузить JVM", "удалить объект", "создать интерфейс"), 0),
    EX9_Q3("Полиморфизм — это:", List.of("инкапсуляция", "одно имя — один смысл", "один интерфейс — много реализаций", "многопоточность"), 2),
    EX10_Q1("Интерфейс содержит:", List.of("реализацию логики", "методы без тела", "файловую систему", "переменные int"), 1),
    EX10_Q2("implements — это:", List.of("реализация интерфейса", "наследование", "exception", "I/O"), 0),
    EX10_Q3("abstract метод:", List.of("финальный", "без реализации", "статический", "обязательно private"), 1),
    EX11_Q1("Исключение обрабатывается с помощью:", List.of("if/else", "do/while", "try/catch", "check/error"), 2),
    EX11_Q2("Блок finally выполняется:", List.of("всегда", "только при ошибке", "только если нет return", "никогда"), 0),
    EX11_Q3("RuntimeException — это:", List.of("фатальный сбой", "ошибка JVM", "unchecked exception", "ошибка компиляции"), 2),
    EX12_Q1("ArrayList объявляется как:", List.of("new List<String>()", "List list = [];", "Array list = new List();", "ArrayList<String> list = new ArrayList<>();"), 3),
    EX12_Q2("HashMap.get(key) возвращает null, если:", List.of("хэш повреждён", "значение 0", "JVM перегружена", "ключа нет"), 3),
    EX12_Q3("Для прохода по списку лучше использовать:", List.of("for-each", "while с индексом", "goto", "рекурсию"), 0),
    EX13_Q1("Автоматическая упаковка — это:", List.of("class → .jar", "int → Integer", "String → char[]", "bytecode → native"), 1),
    EX13_Q2("Что такое wrapper-класс?", List.of("GUI-контейнер", "Класс-наследник", "Обёртка для примитива", "Интерфейс коллекции"), 2),
    EX13_Q3("Integer x = 100; Integer y = 100; x == y → ?", List.of("ошибка", "false", "true", "зависит от ОС"), 2),
    EX14_Q1("enum — это:", List.of("ограниченный набор констант", "интерфейс", "особый поток", "массив строк"), 0),
    EX14_Q2("Можно ли в enum добавить поля?", List.of("только статические", "да", "только в JDK 21+", "нет"), 1),
    EX14_Q3("Как получить все значения enum?", List.of("values()", "getAll()", "constants()", "list()"), 0),
    EX15_Q1("Статический метод вызывается:", List.of("через имя класса", "через new", "только в потоке", "только в main"), 0),
    EX15_Q2("static блок выполняется:", List.of("только в JVM", "при каждом вызове метода", "при загрузке класса", "никогда"), 2),
    EX15_Q3("Что нельзя сделать в static методе?", List.of("использовать this", "возвращать значение", "вызывать другой static", "печатать в консоль"), 0),
    EX16_Q1("Внутренний (non-static) класс имеет доступ к:", List.of("ничего не имеет", "всем полям внешнего класса", "только public", "только static"), 1),
    EX16_Q2("Анонимный класс часто используется для:", List.of("компиляции", "обработчиков событий", "GUI-окон", "хранения чисел"), 1),
    EX16_Q3("Локальный класс объявляется:", List.of("в отдельном файле", "внутри if", "внутри метода", "в интерфейсе"), 2),
    EX17_Q1("Запуск потока происходит через:", List.of("new Thread()", "thread.run()", "thread.start()", "thread.exec()"), 2),
    EX17_Q2("Реализация Runnable предпочтительнее наследования Thread, потому что:", List.of("лучше для GUI", "меньше памяти", "можно наследовать другой класс", "быстрее работает"), 2),
    EX17_Q3("Метод run() не должен вызываться напрямую, потому что:", List.of("нарушает инкапсуляцию", "замедляет JVM", "не создаётся новый поток", "вызывает ошибку"), 2),
    EX18_Q1("synchronized нужен для:", List.of("ускорения потока", "создания объекта", "остановки JVM", "защиты общих данных"), 3),
    EX18_Q2("Гонка данных (race condition) возникает, когда:", List.of("много классов", "мало памяти", "несколько потоков меняют одну переменную", "поток спит"), 2),
    EX18_Q3("wait() и notify() используются для:", List.of("координации потоков", "очистки памяти", "остановки программы", "загрузки классов"), 0),
    EX19_Q1("String в Java:", List.of("неизменяемый", "примитив", "всегда null", "изменяемый"), 0),
    EX19_Q2("Для изменения строки используется:", List.of("char[]", "StringBuilder", "StringBuffer (только в потоке)", "StringEdit"), 1),
    EX19_Q3("\"a\" == \"a\" возвращает:", List.of("true", "ошибку", "null", "false"), 0),
    EX20_Q1("equals() сравнивает:", List.of("хэш-коды", "ссылки", "содержимое объектов", "имена классов"), 2),
    EX20_Q2("hashCode() должен быть переопределён, если:", List.of("класс public", "есть поля", "переопределён equals()", "используется коллекция"), 2),
    EX20_Q3("Если equals() true, то hashCode() должен быть:", List.of("ненулевым", "одинаковым", "разным", "положительным"), 1),
    EX21_Q1("Массив объявляется как:", List.of("int arr = [5];", "new Array(5);", "array int[5];", "int[] arr = new int[5];"), 3),
    EX21_Q2("Длина массива хранится в:", List.of("length(arr)", "arr.count", "arr.size()", "arr.length"), 3),
    EX21_Q3("Многомерный массив в Java — это:", List.of("специальный тип", "матрица в памяти", "только для double", "массив массивов"), 3),
    EX22_Q1("Цикл for-each не подходит, если нужно:", List.of("вывести в консоль", "просто прочитать", "сравнить со строкой", "изменить элементы массива"), 3),
    EX22_Q2("break прерывает:", List.of("текущий цикл", "только switch", "метод", "всю программу"), 0),
    EX22_Q3("continue переходит к:", List.of("блоку finally", "следующему потоку", "началу метода", "следующей итерации"), 3),
    EX23_Q1("&& — это:", List.of("логическое И", "исключающее или", "или", "побитовое И"), 0),
    EX23_Q2("!true равно:", List.of("false", "null", "error", "0"), 0),
    EX23_Q3("Тернарный оператор записывается как:", List.of("a => b : c", "a ? b : c", "if a then b else c", "a ?= b"), 1),
    EX24_Q1("final переменная:", List.of("может быть null", "всегда статическая", "только для чисел", "не может изменяться"), 3),
    EX24_Q2("final класс:", List.of("не создаёт объекты", "только для интерфейсов", "нельзя наследовать", "работает быстрее"), 2),
    EX24_Q3("final метод:", List.of("нельзя переопределять", "всегда private", "статический", "вызывается первым"), 0),
    EX25_Q1("Пакеты используются для:", List.of("хранения строк", "создания GUI", "организации классов", "ускорения JVM"), 2),
    EX25_Q2("Инструкция для подключения класса:", List.of("include", "import", "require", "using"), 1),
    EX25_Q3("Полное имя класса включает:", List.of("JVM + имя", "версию JDK", "пакет и имя", "только имя"), 2),
    EX26_Q1("Класс без модификатора доступа виден:", List.of("только наследникам", "только в main", "в пределах пакета", "везде"), 2),
    EX26_Q2("protected доступен:", List.of("только в том же файле", "в пакете и наследникам", "только в интерфейсе", "всем в JVM"), 1),
    EX26_Q3("Модификатор по умолчанию — это:", List.of("private", "package-private", "public", "protected"), 1),
    EX27_Q1("Переменная в методе — это:", List.of("локальная", "глобальная", "внешняя", "статическая"), 0),
    EX27_Q2("Локальная переменная должна быть:", List.of("вне цикла", "объявлена как final", "инициализирована перед использованием", "типа Object"), 2),
    EX27_Q3("Параметр метода ведёт себя как:", List.of("глобальная", "константа", "локальная переменная", "поле класса"), 2),
    EX28_Q1("Перегрузка конструкторов — это:", List.of("только с super()", "запрещена", "разные имена", "разные параметры"), 3),
    EX28_Q2("this(...) в конструкторе вызывает:", List.of("метод класса", "родительский конструктор", "ошибку", "другой конструктор"), 3),
    EX28_Q3("super() должен быть:", List.of("необязателен", "в конце", "первой строкой конструктора", "в любом месте"), 2),
    EX29_Q1("Абстрактный класс:", List.of("может содержать реализацию", "не может иметь методов", "только для интерфейсов", "всегда final"), 0),
    EX29_Q2("Интерфейс может содержать:", List.of("конструкторы", "default-методы", "поля экземпляра", "private переменные"), 1),
    EX29_Q3("Класс может реализовать:", List.of("только один интерфейс", "много интерфейсов", "ничего, если abstract", "интерфейс и наследовать final"), 1),
    EX30_Q1("Полиморфизм проявляется при:", List.of("компиляции", "вызове переопределённого метода", "объявлении переменной", "создании массива"), 1),
    EX30_Q2("Ссылка типа родителя может указывать на:", List.of("любой объект", "null только", "объект потомка", "только родителя"), 2),
    EX30_Q3("Каст (приведение) нужен, чтобы:", List.of("избежать исключений", "сохранить в файл", "вызвать метод потомка", "ускорить программу"), 2),
    EX31_Q1("Класс Object — это:", List.of("для GUI", "абстрактный", "корень всех классов", "внутренний класс JVM"), 2),
    EX31_Q2("toString() по умолчанию возвращает:", List.of("имя класса + хэш", "ошибку", "пустую строку", "null"), 0),
    EX31_Q3("clone() в Object:", List.of("возвращает null", "останавливает поток", "создаёт копию", "удаляет объект"), 2),
    EX32_Q1("Garbage Collector отвечает за:", List.of("безопасность", "компиляцию", "загрузку классов", "освобождение памяти"), 3),
    EX32_Q2("Объект становится мусором, когда:", List.of("завершён main", "вызван delete", "на него нет ссылок", "JVM спит"), 2),
    EX32_Q3("Метод finalize() вызывается:", List.of("никогда", "перед удалением объекта", "при создании", "каждую секунду"), 1),
    EX33_Q1("System.gc() — это:", List.of("ошибка времени выполнения", "гарантированный сбор", "просьба запустить GC", "остановка программы"), 2),
    EX33_Q2("Стек хранит:", List.of("объекты", "байткод", "локальные переменные и вызовы", "файлы"), 2),
    EX33_Q3("Куча (heap) — это место для:", List.of("объектов", "примитивов", "исключений", "методов"), 0),
    EX34_Q1("Метод main принимает:", List.of("void", "String[] args", "List<String>", "int argc"), 1),
    EX34_Q2("Параметры командной строки передаются в:", List.of("System.in", "main.args", "stdin", "args"), 3),
    EX34_Q3("System.out — это:", List.of("String", "Buffer", "PrintStream", "File"), 2),
    EX35_Q1("Чтобы прочитать строку с консоли, можно использовать:", List.of("Console.in()", "Input.readLine()", "System.read()", "Scanner"), 3),
    EX35_Q2("Scanner(System.in) читает:", List.of("файл", "ввод пользователя", "переменные окружения", "сеть"), 1),
    EX35_Q3("nextInt() после nextLine() может пропустить ввод, потому что:", List.of("ошибка Scanner", "остаётся символ новой строки", "требуется flush()", "нужен reset()"), 1),
    EX36_Q1("Файл открывается через:", List.of("File.open()", "new File()", "readFile()", "FileInputStream"), 3),
    EX36_Q2("try-with-resources автоматически:", List.of("очищает память", "закрывает ресурсы", "ловит исключения", "удаляет файл"), 1),
    EX36_Q3("File не создаёт файл на диске, а только:", List.of("шифрует", "представляет путь", "блокирует его", "читает содержимое"), 1),
    EX37_Q1("Сериализация — это:", List.of("сохранение объекта в поток", "инкапсуляция", "удаление объекта", "компиляция"), 0),
    EX37_Q2("Класс должен реализовать:", List.of("FileIO", "Stream", "Cloneable", "Serializable"), 3),
    EX37_Q3("Поле с transient:", List.of("копируется глубоко", "обязательно null", "шифруется", "не сериализуется"), 3),
    EX38_Q1("Аннотация @Override нужна для:", List.of("замены super", "ускорения метода", "проверки переопределения", "создания интерфейса"), 2),
    EX38_Q2("@SuppressWarnings подавляет:", List.of("вывод в консоль", "ошибки JVM", "предупреждения компилятора", "исключения"), 2),
    EX38_Q3("Аннотации не влияют на:", List.of("размер .class", "производительность", "импорты", "байткод (в большинстве случаев)"), 3),
    EX39_Q1("Generics обеспечивают:", List.of("типобезопасность", "автоматическую сериализацию", "меньше памяти", "ускорение"), 0),
    EX39_Q2("List<String> не позволяет:", List.of("создать пустой список", "использовать в цикле", "добавить Integer", "добавить null"), 2),
    EX39_Q3("Тип стирается при компиляции — это:", List.of("автоупаковка", "инференция", "type erasure", "ковариантность"), 2),
    EX40_Q1("Wildcards в generics: <?>", List.of("запрещено", "только String", "только Number", "любой тип"), 3),
    EX40_Q2("List<? extends Number> позволяет:", List.of("изменять тип", "вызывать doubleValue()", "добавлять Integer", "читать как Number"), 3),
    EX40_Q3("List<? super Integer> позволяет:", List.of("добавлять Integer", "только пустой список", "работать с String", "читать как Integer"), 0),
    EX41_Q1("Класс может быть объявлен как:", List.of("public или package-private", "только public", "только в main", "только private"), 0),
    EX41_Q2("В одном файле может быть несколько классов, если:", List.of("все public", "нет интерфейсов", "все abstract", "один public, остальные нет"), 3),
    EX41_Q3("Имя файла должно совпадать с именем:", List.of("public класса", "первого класса", "main класса", "любого класса"), 0),
    EX42_Q1("Varargs записываются как:", List.of("String* args", "String args...", "String... args", "String[]... args"), 2),
    EX42_Q2("Varargs внутри — это:", List.of("массив", "поток", "список", "итератор"), 0),
    EX42_Q3("Метод с varargs может быть вызван с:", List.of("только 1 аргументом", "не может быть вызван", "0 или более аргументов", "только массивом"), 2),
    EX43_Q1("Класс Class используется для:", List.of("рефлексии", "создания объектов", "сериализации", "GUI"), 0),
    EX43_Q2("Class.forName() загружает:", List.of("файл", "библиотеку", "класс по имени", "JVM"), 2),
    EX43_Q3("Рефлексия позволяет:", List.of("удалить объекты", "заменить интерфейсы", "анализировать классы во время выполнения", "ускорить программу"), 2),
    EX44_Q1("Анонимный класс создаётся через:", List.of("inner {}", "new Interface() { ... }", "lambda", "class { ... }"), 1),
    EX44_Q2("У анонимного класса нет:", List.of("методов", "конструктора", "имени", "доступа к this"), 2),
    EX44_Q3("Анонимный класс может захватывать:", List.of("финальные или эффективно финальные переменные", "только поля", "только static", "все переменные"), 0),
    EX45_Q1("Метод может быть:", List.of("final и abstract", "static и abstract", "final, static, abstract", "private и abstract"), 2),
    EX45_Q2("Статический блок инициализации:", List.of("выполняется один раз", "никогда в интерфейсе", "только в main", "при каждом создании объекта"), 0),
    EX45_Q3("Блок инициализации (без static):", List.of("выполняется перед конструктором", "ошибка компиляции", "заменяет main", "только в abstract"), 0),
    EX46_Q1("Что выведет: System.out.println(10 + 20 + \"30\");", List.of("60", "102030", "3030", "ошибка"), 2),
    EX46_Q2("Что выведет: System.out.println(\"10\" + 20 + 30);", List.of("60", "102030", "ошибка", "1050"), 1),
    EX46_Q3("Результат: 5 / 2 в int:", List.of("2", "3", "2.5", "ошибка"), 0),
    EX47_Q1("Что такое \"утечка памяти\" в Java?", List.of("объекты недостижимы, но не удаляются", "переполнение стека", "много потоков", "JVM сломалась"), 0),
    EX47_Q2("SoftReference используется для:", List.of("замены final", "кеширования", "GUI-объектов", "обязательного хранения"), 1),
    EX47_Q3("WeakHashMap удаляет ключи, когда:", List.of("они становятся слабыми", "вызывается clear()", "истекает время", "JVM завершает работу"), 0),
    EX48_Q1("Паттерн Strategy — это:", List.of("GUI-компоновка", "инкапсуляция алгоритмов", "хранение данных", "создание потоков"), 1),
    EX48_Q2("Композиция предпочтительнее наследования, потому что:", List.of("меньше кода", "лучше для JVM", "гибкость и повторное использование", "быстрее работает"), 2),
    EX48_Q3("Делегирование — это когда:", List.of("класс наследуется", "поток ждёт", "метод вызывает сам себя", "один объект использует другой"), 3),
    EX49_Q1("Swing компоненты:", List.of("GUI, Panel", "Frame, Button", "Window, Click", "JFrame, JButton"), 3),
    EX49_Q2("Обработчик нажатия кнопки — это:", List.of("ClickListener", "ActionListener", "ButtonHandler", "EventRun"), 1),
    EX49_Q3("GUI-поток в Swing называется:", List.of("Event Dispatch Thread", "Main Thread", "Swing Worker", "GUI Runner"), 0),
    EX50_Q1("Head First Java делает упор на:", List.of("тестирование JVM", "только синтаксис", "низкоуровневую оптимизацию", "визуальное и интерактивное обучение"), 3),
    EX50_Q2("Книга учит через:", List.of("головоломки, истории, аналогии", "описание байткода", "только код", "математические формулы"), 0),
    EX50_Q3("Главный принцип книги:", List.of("запомнить все ключевые слова", "заставить мозг учиться", "максимально быстро писать код", "заменить преподавателя"), 1);

    public final String question;
    public final List<String> answers;
    public final int correct;

    JavaQuestions(String question, List<String> answers, int correct) {
        this.question = question;
        this.answers = answers;
        this.correct = correct;
    }

    public static List<TestQuestion> getExercise(int exerciseId) {
        return Arrays.stream(values())
                .filter(q -> q.name().startsWith("EX" + exerciseId + "_"))
                .map(q -> new TestQuestion(q.question, q.answers, q.correct))
                .toList();
    }

    public static boolean hasExercise(int exerciseId) {
        return Arrays.stream(values())
                .anyMatch(q -> q.name().startsWith("EX" + exerciseId + "_"));
    }
}
