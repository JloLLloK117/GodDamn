package Window.Studing;

import java.util.*;

public enum CppQuestions {
    EX1_Q1("Какой заголовок включает стандартный вывод в C++?", List.of("#include <stdio.h>", "#include <stream>", "#include <iostream>", "#include <cout>"), 2),
    EX1_Q2("Точка входа в программу на C++:", List.of("int main()", "program()", "void main()", "start()"), 0),
    EX1_Q3("Команда для компиляции с g++:", List.of("run prog.cpp", "compile prog", "g++ prog.cpp -o prog", "gcc prog.cpp"), 2),
    EX2_Q1("Правильная инициализация в стиле C++11:", List.of("int x = 42;", "все верны, но {} предпочтительна", "int x{42};", "int x(42);"), 2),
    EX2_Q2("Тип auto выводится на основе:", List.of("файла", "имени переменной", "инициализатора", "компилятора по умолчанию"), 2),
    EX2_Q3("decltype(expr) даёт:", List.of("тип без const", "точный тип выражения", "ошибку компиляции", "int всегда"), 1),
    EX3_Q1("Для использования std::string нужно:", List.of("#include <str>", "ничего — встроенный тип", "#include <cstring>", "#include <string>"), 3),
    EX3_Q2("std::vector<int> v(10); создаёт:", List.of("пустой вектор", "10 элементов со значением 0", "ошибку — нет конструктора", "вектор из 10 указателей"), 1),
    EX3_Q3("Метод size() у string и vector возвращает:", List.of("ёмкость", "байты", "количество элементов", "макс. размер"), 2),
    EX4_Q1("Диапазонный for-цикл записывается как:", List.of("foreach (x : container)", "for (x in container)", "for (auto x : container)", "for (auto& x = container)"), 2),
    EX4_Q2("if с инициализацией (C++17+):", List.of("не поддерживается в C++11", "if let (x = f())", "if (int x = f())", "if (auto x = f(); x > 0)"), 0),
    EX4_Q3("Ветка else связана с:", List.of("ошибкой, если нет {}", "ближайшим if без else", "первым if", "всегда с внешним if"), 1),
    EX5_Q1("Приоритет * выше, чем + — это:", List.of("зависит от компилятора", "нет", "да", "только для double"), 2),
    EX5_Q2("x = y = 0; работает, потому что =", List.of("ассоциативен слева", "не ассоциативен", "это ошибка", "ассоциативен справа"), 3),
    EX5_Q3("Результат: 5 / 2 в int:", List.of("неопределён", "2", "3", "2.5"), 1),
    EX6_Q1("Параметр по значению:", List.of("не может быть изменён", "ссылается на оригинал", "должен быть const", "получает копию аргумента"), 3),
    EX6_Q2("Функция без return в конце:", List.of("допустима, если возвращает void", "всегда ошибка", "работает только в main", "вызывает исключение"), 0),
    EX6_Q3("Объявление функции без тела — это:", List.of("определение", "шаблон", "прототип", "ошибка"), 2),
    EX7_Q1("const string& как параметр — это:", List.of("запрещено в C++", "только для литералов", "передача по значению", "эффективная передача без копирования"), 3),
    EX7_Q2("Передача по указателю позволяет:", List.of("заменить return", "ускорить программу", "изменять оригинал", "избегать ссылок"), 2),
    EX7_Q3("Массив в параметре функции:", List.of("запрещён", "копируется", "декэйится в указатель", "передаётся целиком"), 2),
    EX8_Q1("Возврат по значению в C++11 оптимизируется через:", List.of("исключения", "автоматический указатель", "копирование всегда", "RVO / перемещение"), 3),
    EX8_Q2("Нельзя возвращать:", List.of("копию строки", "ссылку на локальную переменную", "указатель на static", "int"), 1),
    EX8_Q3("Функция может возвращать:", List.of("только примитивы", "любой тип", "не может возвращать массив", "только void или int"), 1),
    EX9_Q1("Перегрузка функций различается по:", List.of("файлу", "возвращаемому типу", "имени", "типу или количеству параметров"), 3),
    EX9_Q2("main() можно перегрузить?", List.of("да", "только в шаблонах", "только в C++17 можно", "нет"), 3),
    EX9_Q3("const в конце метода означает:", List.of("возвращаемое значение const", "функция inline", "объект не модифицируется", "параметры const"), 2),
    EX10_Q1("Члены класса по умолчанию:", List.of("private", "protected", "доступны всем", "public"), 0),
    EX10_Q2("Конструктор без параметров — это:", List.of("конструктор по умолчанию", "специальный метод", "деструктор", "копирующий конструктор"), 0),
    EX10_Q3("Деструктор вызывается:", List.of("только для указателей", "никогда в стеке", "вручную через delete", "автоматически при уничтожении объекта"), 3),
    EX11_Q1("Список инициализации в конструкторе:", List.of("инициализирует члены до тела", "для static только", "не влияет на производительность", "заменяет тело"), 0),
    EX11_Q2("RAII означает:", List.of("управление ресурсами через время жизни объекта", "работа с файлами", "оптимизацию компилятором", "ручное удаление памяти"), 0),
    EX11_Q3("Конструктор копирования вызывается при:", List.of("объявлении указателя", "передаче объекта по значению", "вызове метода", "присваивании"), 1),
    EX12_Q1("shared_ptr управляет временем жизни через:", List.of("счётчик ссылок", "GC", "стек", "ручной вызов free"), 0),
    EX12_Q2("unique_ptr гарантирует:", List.of("множественное владение", "единственное владение", "работу в потоках без блокировок", "автоматическое копирование"), 1),
    EX12_Q3("make_shared() предпочтительнее new, потому что:", List.of("требуется в C++17", "работает быстрее", "эффективнее и безопаснее", "поддерживает наследование"), 2),
    EX13_Q1("Перемещающий конструктор принимает:", List.of("const T&", "rvalue-ссылку (T&&)", "указатель", "lvalue-ссылку"), 1),
    EX13_Q2("std::move превращает в:", List.of("rvalue", "lvalue", "const объект", "указатель"), 0),
    EX13_Q3("После перемещения объект:", List.of("находится в валидном, но неопределённом состоянии", "ошибка использовать", "становится null", "удаляется"), 0),
    EX14_Q1("Оператор = должен возвращать:", List.of("bool", "ссылку на *this", "void", "копию объекта"), 1),
    EX14_Q2("Оператор [] обычно возвращает:", List.of("указатель", "копию", "итератор", "ссылку на элемент"), 3),
    EX14_Q3("Перегрузка << для вывода:", List.of("только friend", "методом класса", "запрещена", "должна быть свободной функцией"), 3),
    EX15_Q1("public наследование означает:", List.of("автоматическое копирование", "«является» (is-a)", "«содержит» (has-a)", "доступ ко всем полям"), 1),
    EX15_Q2("Конструктор производного класса:", List.of("требует virtual", "вызывает конструктор базового", "игнорирует базовый", "должен вызывать вручную"), 1),
    EX15_Q3("Порядок вызова деструкторов:", List.of("базовый → производный", "зависит от new/delete", "случайный", "производный → базовый"), 3),
    EX16_Q1("virtual функция позволяет:", List.of("вызывать реализацию производного класса через указатель на базовый", "заменить шаблоны", "избежать наследования", "ускорить программу"), 0),
    EX16_Q2("Чисто виртуальная функция записывается как:", List.of("abstract void f();", "virtual void f() = 0;", "void f() override;", "virtual void f();"), 1),
    EX16_Q3("Абстрактный класс:", List.of("всегда final", "не может иметь методов", "нельзя создавать объекты", "только для интерфейсов"), 2),
    EX17_Q1("Шаблон функции объявляется с:", List.of("generic<T>", "class T", "template<typename T>", "auto T"), 2),
    EX17_Q2("Шаблоны инстанцируются:", List.of("линкером", "на этапе выполнения", "предпроцессором", "на этапе компиляции"), 3),
    EX17_Q3("typename в шаблоне используется для:", List.of("создания объекта", "замены class", "ограничения параметров", "указания, что имя — тип"), 3),
    EX18_Q1("vector хранит элементы:", List.of("в непрерывной памяти", "в связном списке", "в дереве", "в хэш-таблице"), 0),
    EX18_Q2("map упорядочен по:", List.of("значению", "ключу", "хэшу", "времени вставки"), 1),
    EX18_Q3("unordered_map использует:", List.of("хэш-таблицу", "список", "красно-чёрное дерево", "массив"), 0),
    EX19_Q1("Алгоритмы STL работают с:", List.of("указателями напрямую", "только vector", "индексами", "итераторами"), 3),
    EX19_Q2("find возвращает:", List.of("bool", "индекс", "итератор на найденный или end()", "значение"), 2),
    EX19_Q3("sort требует:", List.of("двунаправленный итератор", "только массивы", "случайный доступ (random-access iterator)", "уникальные значения"), 2),
    EX20_Q1("Лямбда записывается как:", List.of("() => { }", "auto fn = { }", "lambda { }", "[]() { }"), 3),
    EX20_Q2("Захват по значению: [x]", List.of("делает x const", "ссылается на x", "ошибка, если x не static", "копирует x"), 3),
    EX20_Q3("Захват [&] означает:", List.of("все переменные по ссылке", "все по значению", "запрещено в алгоритмах", "только const"), 0),
    EX21_Q1("Для чтения файла используется:", List.of("fstream", "file.open()", "cin", "ifstream"), 3),
    EX21_Q2("ofstream открывает файл для:", List.of("бинарного режима", "записи", "добавления", "чтения"), 1),
    EX21_Q3("Проверка успешности открытия:", List.of("все верны", "if (file.is_open())", "if (file.good())", "if (file)"), 1),
    EX22_Q1("Исключение выбрасывается через:", List.of("raise", "error", "except", "throw"), 3),
    EX22_Q2("Блок catch(...) ловит:", List.of("ошибки памяти", "только int", "только std::exception", "все исключения"), 3),
    EX22_Q3("RAII помогает при исключениях, потому что:", List.of("память не утекает", "исключения отключаются", "компилятор оптимизирует", "деструкторы вызываются всегда"), 3),
    EX23_Q1("Преобразование string в int:", List.of("stoi(s)", "int(s)", "atoi(s)", "parse(s)"), 0),
    EX23_Q2("s.substr(2, 3) возвращает:", List.of("ошибку", "всю строку после 2", "символы 2–3", "3 символа с позиции 2"), 3),
    EX23_Q3("s.find(\"a\") возвращает:", List.of("bool", "итератор", "позицию или string::npos", "новую строку"), 2),
    EX24_Q1("shared_ptr потокобезопасен для:", List.of("одного объекта из нескольких потоков", "всегда", "никогда", "разных объектов shared_ptr"), 3),
    EX24_Q2("Модификация одного объекта из нескольких потоков без синхронизации:", List.of("опасна", "разрешена в C++11", "автоматически сериализуется", "только для const"), 0),
    EX24_Q3("mutex защищает:", List.of("только указатели", "только статические переменные", "весь класс", "разделённые данные"), 3),
    EX25_Q1("auto x = {1, 2, 3}; делает x типом:", List.of("vector<int>", "int[3]", "ошибка", "std::initializer_list<int>"), 3),
    EX25_Q2("decltype(x) при x = 42 (int):", List.of("int&", "42", "const int", "int"), 3),
    EX25_Q3("auto& y = x; сохраняет:", List.of("только тип", "ничего", "ссылочность и const", "только значение"), 2),
    EX26_Q1("const метод не может:", List.of("вызывать другие методы", "изменять члены класса", "быть виртуальным", "возвращать значения"), 1),
    EX26_Q2("mutable позволяет:", List.of("игнорировать const", "создавать копии", "изменять поле в const-методе", "ускорить доступ"), 2),
    EX26_Q3("const int* p означает:", List.of("константный указатель", "ошибка синтаксиса", "указатель на константное значение", "оба константны"), 2),
    EX27_Q1("using namespace std; — это:", List.of("определение типа", "макрос", "директива using", "объявление пространства"), 2),
    EX27_Q2("Анонимное пространство имён:", List.of("глобальное для всех файлов", "только для шаблонов", "запрещено в C++11", "имитирует static в C"), 3),
    EX27_Q3("std:: — это:", List.of("класс", "пространство имён стандартной библиотеки", "макрос", "ключевое слово"), 1),
    EX28_Q1("static член класса:", List.of("общий для всех объектов", "должен быть const", "не может быть private", "уникален для каждого объекта"), 0),
    EX28_Q2("Определение static члена вне класса:", List.of("только в заголовке", "запрещено", "автоматически компилятором", "обязательно для не const"), 3),
    EX28_Q3("static метод не имеет доступа к:", List.of("this и нестатическим членам", "const полям", "публичным методам", "дружественным функциям"), 0),
    EX29_Q1("friend функция имеет доступ к:", List.of("только static", "только private", "только public", "всем членам класса"), 3),
    EX29_Q2("Дружба не наследуется и не транзитивна — это:", List.of("только в C++17", "правда", "зависит от компилятора", "ложь"), 1),
    EX29_Q3("Часто friend используется для:", List.of("наследования", "шаблонов", "виртуальных функций", "перегрузки операторов << и >>"), 3),
    EX30_Q1("explicit запрещает:", List.of("копирование", "неявные преобразования", "перемещение", "наследование"), 1),
    EX30_Q2("explicit применяется к:", List.of("деструкторам", "операторам", "конструкторам с одним параметром", "всем методам"), 2),
    EX30_Q3("Без explicit: f(MyClass x) можно вызвать как f(42), если есть конструктор MyClass(int) — это:", List.of("разрешено всегда", "неявное преобразование", "только в C", "ошибка"), 1),
    EX31_Q1("enum class в C++11:", List.of("строго типизирован", "только для int", "как обычный enum", "не может иметь методов"), 0),
    EX31_Q2("Обычный enum попадает в:", List.of("область видимости внешнего кода", "ошибку компиляции", "только в класс", "отдельное пространство"), 0),
    EX31_Q3("enum Color { Red }; — Red имеет тип:", List.of("Color", "int (в обычном enum)", "size_t", "const int"), 1),
    EX32_Q1("Указатель на метод объявляется как:", List.of("auto ptr = &Class::f;", "void* ptr;", "method_ptr ptr;", "void (Class::*ptr)();"), 3),
    EX32_Q2("Вызов через указатель на метод:", List.of("(obj.*ptr)();", "ptr(obj);", "obj->ptr();", "call ptr on obj"), 0),
    EX32_Q3("Указатель на член — редко используется, чаще применяют:", List.of("наследование", "шаблоны", "лямбды или std::function", "макросы"), 2),
    EX33_Q1("Функтор — это:", List.of("объект с operator()", "указатель на функцию", "макрос", "лямбда"), 0),
    EX33_Q2("std::function<void()> может хранить:", List.of("любой вызываемый объект", "только функторы", "только лямбды", "только функции"), 0),
    EX33_Q3("bind устарел в C++14 в пользу:", List.of("макросов", "шаблонов", "автоматических функций", "лямбд"), 3),
    EX34_Q1("for_each применяет функцию к:", List.of("каждому элементу", "первому элементу", "чётным элементам", "итераторам"), 0),
    EX34_Q2("transform создаёт:", List.of("удаляет элементы", "изменяет исходную", "новую последовательность", "возвращает bool"), 2),
    EX34_Q3("Алгоритмы не изменяют размер контейнера, кроме:", List.of("только find", "все могут", "никакие — они работают с итераторами", "только sort"), 2),
    EX35_Q1("Для работы с потоками нужно:", List.of("#include <thread>", "#include <pthread.h>", "#include <concurrency>", "POSIX только"), 0),
    EX35_Q2("std::thread t(func); запускает:", List.of("новый поток", "функцию в текущем потоке", "обработчик", "асинхронную задачу"), 0),
    EX35_Q3("t.join() означает:", List.of("ожидание завершения потока", "отделение потока", "перезапуск", "остановку"), 0),
    EX36_Q1("std::async возвращает:", List.of("std::future", "std::thread", "void", "результат немедленно"), 0),
    EX36_Q2("future.get() блокирует до:", List.of("получения результата", "ошибки", "таймаута", "завершения программы"), 0),
    EX36_Q3("launch::async гарантирует:", List.of("отмену", "запуск в отдельном потоке", "ленивое вычисление", "выполнение в текущем потоке"), 1),
    EX37_Q1("Для regex нужно:", List.of("#include <re>", "C-style", "#include <regex>", "Boost только"), 2),
    EX37_Q2("std::regex_match проверяет:", List.of("разделение", "замену", "полное совпадение", "частичное"), 2),
    EX37_Q3("regex_search ищет:", List.of("первое совпадение в строке", "только в начале", "все совпадения", "только цифры"), 0),
    EX38_Q1("Для работы со временем:", List.of("#include <time.h>", "#include <datetime>", "только C-функции", "#include <chrono>"), 3),
    EX38_Q2("high_resolution_clock::now() возвращает:", List.of("длительность", "таймер", "текущее время", "ошибку"), 2),
    EX38_Q3("duration_cast преобразует:", List.of("локальное время", "время в строку", "одну длительность в другую", "секунды в часы"), 2),
    EX39_Q1("new/delete заменяются на:", List.of("умные указатели", "никогда не заменяются", "автоматические переменные", "malloc/free"), 0),
    EX39_Q2("placement new используется для:", List.of("работы с файлами", "конструирования в выделенной памяти", "оптимизации циклов", "перемещения объектов"), 1),
    EX39_Q3("Утечка памяти — это:", List.of("слишком много переменных", "использование delete два раза", "память не удалена, и нет указателя", "работа с вектором"), 2),
    EX40_Q1("noexcept означает:", List.of("только для деструкторов", "функция всегда падает", "устаревшее", "функция не выбрасывает исключений"), 3),
    EX40_Q2("Деструкторы по умолчанию:", List.of("noexcept", "всегда бросают", "зависит от членов", "могут бросать"), 0),
    EX40_Q3("Если noexcept-функция бросает — вызывается:", List.of("std::terminate", "ничего", "ошибка компиляции", "catch(...)"), 0),
    EX41_Q1("Если определён перемещающий конструктор, компилятор:", List.of("требует явного указания", "генерирует оба", "удаляет оба", "не генерирует копирующий"), 3),
    EX41_Q2("Правило пяти (Rule of Five):", List.of("пять виртуальных функций", "пять типов указателей", "деструктор, копия/перемещение, присваивание", "пять шаблонов"), 2),
    EX41_Q3("Класс с raw-указателем должен:", List.of("запретить копирование", "использовать только shared_ptr", "игнорировать RAII", "управлять ресурсами явно"), 3),
    EX42_Q1("Композиция vs наследование:", List.of("наследование быстрее", "наследование безопаснее", "одно и то же", "композиция гибче"), 3),
    EX42_Q2("Принцип “открытости/закрытости”:", List.of("закрыт для наследования", "только для интерфейсов", "открыт для расширения, закрыт для изменения", "всё должно быть public"), 2),
    EX42_Q3("Pimpl idiom используется для:", List.of("сокрытия реализации", "ускорения компиляции", "работы с потоками", "замены наследования"), 0),
    EX43_Q1("Использование сырых указателей:", List.of("лучше умных", "обязательно", "не рекомендуется", "только в main"), 2),
    EX43_Q2("Неинициализированная переменная:", List.of("ошибка компиляции", "вызывает исключение", "равна 0", "содержит мусор"), 3),
    EX43_Q3("const корректность — это:", List.of("использование const там, где возможно", "стиль кода", "оптимизация", "запрет изменений"), 0),
    EX44_Q1("assert используется для:", List.of("обработки ошибок", "логирования", "проверки условий в отладке", "выброса исключений"), 2),
    EX44_Q2("NDEBUG отключает:", List.of("предупреждения", "оптимизацию", "исключения", "assert"), 3),
    EX44_Q3("Unit-тесты в C++ часто пишут с:", List.of("Google Test", "CUnit только", "JUnit", "вручную"), 0),
    EX45_Q1("extern \"C\" отключает:", List.of("исключения", "mangling имён", "шаблоны", "наследование"), 1),
    EX45_Q2("Можно ли включать .h из C в C++?", List.of("автоматически", "только через #ifdef", "нет", "да, с осторожностью"), 3),
    EX45_Q3("malloc/free не вызывают:", List.of("конструкторы/деструкторы", "ошибки", "утечки", "предупреждения"), 0),
    EX46_Q1("Заголовочный файл должен содержать:", List.of("определения", "всё сразу", "main()", "объявления"), 3),
    EX46_Q2("include guard предотвращает:", List.of("ошибки линковки", "утечки", "многократное включение", "медленную компиляцию"), 2),
    EX46_Q3("#pragma once — это:", List.of("альтернатива include guard", "стандарт C++", "устаревшее", "только для GCC"), 0),
    EX47_Q1("Шаблонный параметр может быть:", List.of("только int", "только классом", "только типом", "типом, значением, шаблоном"), 3),
    EX47_Q2("SFINAE используется для:", List.of("вывода допустимости шаблона", "работы с файлами", "оптимизации циклов", "замены исключений"), 0),
    EX47_Q3("Явная специализация шаблона:", List.of("автоматическая", "запрещена", "переопределяет поведение для типа", "только для функций"), 2),
    EX48_Q1("Для бинарного режима в fstream:", List.of("bin", "mode=2", "std::ios::binary", "binary=true"), 2),
    EX48_Q2("reinterpret_cast опасен, потому что:", List.of("не компилируется", "только для int", "нарушает типобезопасность", "медленный"), 2),
    EX48_Q3("union позволяет:", List.of("работать с потоками", "хранить разные типы в одной памяти", "заменить наследование", "ускорить программу"), 1),
    EX49_Q1("Copy elision — это:", List.of("перемещение", "оптимизация, устраняющая копии", "ошибка компилятора", "устаревшая техника"), 1),
    EX49_Q2("Инлайнинг функций:", List.of("запрещён в C++11", "только для шаблонов", "всегда замедляет", "может ускорить код"), 3),
    EX49_Q3("Profile-guided optimization (PGO):", List.of("встроена в g++ по умолчанию", "использует данные выполнения", "только для Windows", "не работает с STL"), 1),
    EX50_Q1("Основной принцип C++: ", List.of("«всё — объект»", "«простота прежде всего»", "«автоматическая сборка мусора»", "«не плати за то, чем не пользуешься»"), 3),
    EX50_Q2("C++ поддерживает парадигмы:", List.of("только ООП", "только функциональную", "процедурную, ООП, обобщённую", "только низкоуровневую"), 2),
    EX50_Q3("C++ Primer учит:", List.of("замене Java", "только синтаксису", "идиоматическому, современному C++", "работе с Windows API"), 2);

    public final String question;
    public final List<String> answers;
    public final int correct;

    CppQuestions(String question, List<String> answers, int correct) {
        this.question = question;
        this.answers = answers;
        this.correct = correct;
    }

    public static List<TestQuestion> getExercise(int exerciseId) {
        return Arrays.stream(values())
                .filter(q -> q.name().startsWith("EX" + exerciseId + "_"))
                .map(q -> new TestQuestion(q.question, q.answers, q.correct))
                .toList();
    }

    public static boolean hasExercise(int exerciseId) {
        return Arrays.stream(values())
                .anyMatch(q -> q.name().startsWith("EX" + exerciseId + "_"));
    }
}
